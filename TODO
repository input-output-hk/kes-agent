File formats
============

Generally: JSON TextEnvelope, where
    teType :: String
    teDescription :: String
    teRawCBOR :: ByteString

instance ToJSON TextEnvelope where
  toJSON TextEnvelope {teType, teDescription, teRawCBOR} =
    object [ "type"        .= teType
           , "description" .= teDescription
           , "cborHex"     .= Text.decodeUtf8 (Base16.encode teRawCBOR)
           ]

instance FromJSON TextEnvelope where
  parseJSON = withObject "TextEnvelope" $ \v ->
                TextEnvelope <$> (v .: "type")
                             <*> (v .: "description")
                             <*> (parseJSONBase16 =<< v .: "cborHex")
    where
      parseJSONBase16 v =
        either fail return . Base16.decode . Text.encodeUtf8 =<< parseJSON v

-----

Cold sign key:
    teType = "StakePoolSigningKey_" ++ algorithmNameDSIGN (DSIGN crypto)

Cold ver key:
    teType = "StakePoolVerificationKey_" ++ algorithmNameDSIGN (DSIGN crypto)

KES VerKey:
    teType = "KesVerificationKey_" ++ algorithmNameKES (KES crypto)
    teDescription = "KES Verification Key"
    teRawCBOR = Cardano.Binary.serialize' vk

Operational Certificate:
    teType = "NodeOperationalCertificate"
    teDescription = Nothing
    teRawCBOR = Cardano.Binary.serialize' (opcert, vkCold)

TextEnvelope:
    teType, teDescription, teRawCBOR
